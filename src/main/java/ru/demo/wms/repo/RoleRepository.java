package ru.demo.wms.repo;

import org.springframework.data.jpa.repository.JpaRepository;

import ru.demo.wms.consts.RoleType;
import ru.demo.wms.model.Role;

public interface RoleRepository 
	extends JpaRepository<Role, Integer> 
{
	//SQL: (select count(role) from roletab where role=?)>0?true:false
	Boolean existsByRole(RoleType role);
}
/*Этот интерфейс RoleRepository является репозиторием Spring Data JPA для сущности Role, предназначенным для работы с ролями пользователей в системе. Он расширяет JpaRepository, предоставляя базовые операции CRUD (создание, чтение, обновление, удаление) для объектов Role, а также дополнительные методы для управления этими объектами.

Особенность метода:
existsByRole: Этот метод предоставляет способ проверить существование роли в базе данных, принимая в качестве параметра role тип RoleType, который предположительно является перечислением, определяющим различные типы ролей в системе. Метод возвращает Boolean, где true означает, что роль с заданным типом существует, а false — что не существует.
Преимущества использования:
Упрощение кода: Вместо написания пользовательского SQL-запроса для проверки существования роли метод existsByRole позволяет выполнить эту операцию одним вызовом метода, значительно упрощая код и повышая его читаемость.

Типобезопасность: Использование типа RoleType вместо строк или чисел для указания роли повышает типобезопасность, уменьшая вероятность ошибок во время компиляции и упрощая рефакторинг кода.

Интеграция с Spring Data: Методы, такие как existsByRole, полностью интегрированы с Spring Data JPA, обеспечивая автоматическую реализацию без необходимости писать дополнительный код для доступа к базе данных или управления транзакциями.

Пример использования:
Метод existsByRole может быть использован в сервисе или контроллере для проверки, прежде чем выполнить операции, зависящие от наличия или отсутствия определенной роли в системе. Например, перед добавлением новой роли в базу данных можно проверить, не существует ли уже такая роль, чтобы избежать дублирования.

Этот подход уменьшает количество кода, необходимого для выполнения таких проверок, и делает код более чистым и понятным, улучшая тем самым общую архитектуру приложения и его поддерживаемость.*/